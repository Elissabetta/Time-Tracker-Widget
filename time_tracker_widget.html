<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Widget Tracciamento Tempo con Timer Dinamico</title>
    <!-- Caricamento di Tailwind CSS per lo styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Stili personalizzati per l'aspetto widget */
        :root {
            --bg-color: #1f2937;
            --text-color: #f9fafb;
        }
        body {
            background-color: #0f172a;
            font-family: 'Inter', sans-serif;
            color: var(--text-color);
            padding: 20px;
        }
        .widget-card {
            background-color: var(--bg-color);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 4px, 0, 0.1);
        }
        .activity-button {
            transition: all 0.15s ease-in-out;
            min-height: 48px;
            /* Rimuove le limitazioni di testo, permette wrap */
            white-space: normal; 
            overflow: visible;
            text-overflow: clip;
        }
        .activity-button:hover:not(.active) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16, 185, 129, 0.3);
        }
        .active {
            animation: pulse-red 1.5s infinite;
        }
        @keyframes pulse-red {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); /* Rosso per STOP */
            }
            50% {
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }
        }
        .management-input {
            background-color: #111827;
            border: 1px solid #4b5563;
            color: #f9fafb;
        }
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.75);
            z-index: 1000;
        }
        .modal-content {
            z-index: 1001;
            background-color: var(--bg-color);
        }
        /* Stile per l'input file nascosto */
        #importFileInput {
            display: none;
        }
    </style>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ====================================================================================
        // GESTIONE AMBIENTE LOCALE (SOLO PER ESECUZIONE SU DESKTOP)
        // Definizioni fittizie per evitare l'errore "Configurazione Firebase mancante" in locale.
        const __app_id = 'local-app-id-tracker';
        const __firebase_config = '{}'; // Configurazione vuota per forzare il fallback locale.
        const __initial_auth_token = 'local-auth-token';
        // ====================================================================================


        // Global Firebase variables provided by Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app;
        let db;
        let auth;
        let userId = 'loading';
        
        // Timer globale per l'aggiornamento dinamico dei secondi
        let timerInterval = null; 
        
        // Firestore paths
        const PUBLIC_PATH_PREFIX = `artifacts/${appId}/public/data/`;
        const STATE_DOC_PATH = PUBLIC_PATH_PREFIX + 'trackerState/main';
        
        // Default Configuration (used only if Firestore document is empty)
        const DEFAULT_ACTIVITIES = [
            { id: 'studio', name: 'Studio Accademico', color: 'bg-indigo-600', hover: 'hover:bg-indigo-700' },
            { id: 'progetto', name: 'Progetto Personale', color: 'bg-amber-600', hover: 'hover:bg-amber-700' }
        ];
        
        // Colori predefiniti per le attività importate
        const randomColorMap = {};
        const availableColors = [
            'bg-red-600', 'bg-green-600', 'bg-blue-600', 'bg-purple-600', 
            'bg-pink-600', 'bg-teal-600', 'bg-fuchsia-600', 'bg-cyan-600'
        ];
        
        let state = {
            activities: [],
            activeActivity: null,
            logs: [],
            runningTotalMs: {},
        };

        // Dichiarazione delle funzioni di persistenza (saranno reindirizzate in initFirebase o initLocalFallback)
        let saveState = () => console.warn("SaveState non inizializzato.");
        let addLogToDatabase = (log) => console.warn("addLogToDatabase non inizializzato.");

        // --- Firebase Initialization and Auth ---

        async function initFirebase() {
            // Se la configurazione è vuota (come nel caso locale), usiamo il fallback a localStorage.
            if (Object.keys(firebaseConfig).length === 0) {
                document.getElementById('local-warning').classList.remove('hidden');
                document.getElementById('status').textContent = 'Modalità Locale (senza DB cloud).';
                userId = 'local-user-id'; // Definisce un ID utente locale fittizio
                document.getElementById('user-id-display').textContent = `Utente ID: ${userId} (Locale)`;
                initLocalFallback(); 
                return;
            }
            
            setLogLevel('Debug');
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            // Authentication using custom token or anonymous sign-in
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Errore nell'autenticazione Firebase:", error);
                document.getElementById('status').textContent = 'Errore di Autenticazione.';
            }

            // Get User ID and start listening to data
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    document.getElementById('user-id-display').textContent = `Utente ID: ${userId}`;
                    
                    // Assegna le funzioni Firestore
                    saveState = saveStateFirestore;
                    addLogToDatabase = addLogToDatabaseFirestore;

                    startFirestoreListeners();
                } else {
                    document.getElementById('status').textContent = 'Autenticazione Fallita.';
                }
            });
        }

        // --- Firestore Persistence (Remote) ---

        function saveStateFirestore() {
            if (db) {
                // Non salviamo i log qui, solo le attività, i totali e l'attività attiva.
                const stateToSave = {
                    activities: state.activities,
                    activeActivity: state.activeActivity,
                    runningTotalMs: state.runningTotalMs
                };
                updateDoc(doc(db, STATE_DOC_PATH), stateToSave).catch(error => {
                    console.error("Errore nel salvataggio dello stato principale (Firestore):", error);
                });
            }
        }

        function addLogToDatabaseFirestore(logEntry) {
            if (db) {
                const logsCollectionRef = collection(db, PUBLIC_PATH_PREFIX + 'activityLogs');
                setDoc(doc(logsCollectionRef), logEntry).catch(error => {
                     console.error("Errore nell'aggiunta del log (Firestore):", error);
                });
            }
        }

        function startFirestoreListeners() {
             // Listener per lo stato principale (attività, totali, attività attiva)
            onSnapshot(doc(db, STATE_DOC_PATH), (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const loadedState = docSnapshot.data();
                    state.activities = loadedState.activities || DEFAULT_ACTIVITIES;
                    state.activeActivity = loadedState.activeActivity || null;
                    state.runningTotalMs = loadedState.runningTotalMs || {};
                    
                    state.activities.forEach(activity => {
                        if (!state.runningTotalMs[activity.id]) {
                            state.runningTotalMs[activity.id] = 0;
                        }
                    });

                    renderUI();
                    document.getElementById('status').textContent = 'Connesso al DB cloud.';
                } else {
                    setDoc(doc(db, STATE_DOC_PATH), { activities: DEFAULT_ACTIVITIES, activeActivity: null, runningTotalMs: {} });
                }
            }, (error) => {
                console.error("Errore nel listener dello stato:", error);
                document.getElementById('status').textContent = `Errore di connessione: ${error.code}`;
            });

            // Listener per i log
            const logsCollectionRef = collection(db, PUBLIC_PATH_PREFIX + 'activityLogs');
            const q = query(logsCollectionRef);

            onSnapshot(q, (querySnapshot) => {
                const newLogs = [];
                querySnapshot.forEach((doc) => {
                    newLogs.push(doc.data());
                });
                
                newLogs.sort((a, b) => b.startTime - a.startTime);
                state.logs = newLogs;
                renderLogs();
            }, (error) => {
                console.error("Errore nel listener dei log:", error);
            });
        }
        
        // --- Modalità Locale (Fallback) - Persistence via localStorage ---
        const LOCAL_STORAGE_KEY = 'timeTrackerLocalData';

        function initLocalFallback() {
            // Carica lo stato da localStorage
            try {
                const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (storedData) {
                    const loadedState = JSON.parse(storedData);
                    state.activities = loadedState.activities || DEFAULT_ACTIVITIES;
                    state.activeActivity = loadedState.activeActivity || null;
                    state.runningTotalMs = loadedState.runningTotalMs || {};
                    state.logs = loadedState.logs || []; 
                } else {
                    state.activities = DEFAULT_ACTIVITIES;
                }
                
                state.activities.forEach(activity => {
                    if (!state.runningTotalMs[activity.id]) {
                        state.runningTotalMs[activity.id] = 0;
                    }
                });

            } catch (e) {
                console.error("Errore nel caricamento dello stato locale. Reset:", e);
                state = { activities: DEFAULT_ACTIVITIES, activeActivity: null, logs: [], runningTotalMs: {} };
            }
            // Assegniamo le funzioni locali per persistenza e log
            saveState = saveLocalState;
            addLogToDatabase = addLocalLog;

            renderUI();
            renderLogs();
        }

        function saveLocalState() {
            try {
                const stateToSave = {
                    activities: state.activities,
                    activeActivity: state.activeActivity,
                    runningTotalMs: state.runningTotalMs,
                    logs: state.logs 
                };
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(stateToSave));
            } catch (e) {
                console.error("Errore nel salvataggio dello stato in localStorage:", e);
            }
        }
        
        function addLocalLog(logEntry) {
            state.logs.unshift(logEntry);
            saveLocalState(); 
            // [FEEDBACK FIX] Assicura che i log si aggiornino in modalità locale subito dopo il salvataggio
            renderUI(); 
        }

        // --- Funzioni di Utility ---

        /** Genera un ID univoco breve per le nuove attività. */
        function generateId() {
            return Math.random().toString(36).substring(2, 9);
        }

        /** Formatta un numero di millisecondi in H ore M minuti S secondi. */
        function formatDuration(ms, running = false) {
            if (ms < 0 || isNaN(ms)) return running ? "00:00" : "0s";
            
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            const pad = (num) => String(num).padStart(2, '0');

            // Formato per il timer in esecuzione (MM:SS o Hh MM:SS)
            if (running) {
                if (hours > 0) {
                    return `${hours}h ${pad(minutes)}:${pad(seconds)}`;
                }
                return `${pad(minutes)}:${pad(seconds)}`;
            }
            
            // Formato per i log e i totali cumulativi (Hh Mm Ss)
            const displayHours = hours > 0 ? `${hours}h ` : '';
            const displayMinutes = minutes > 0 ? `${minutes}m ` : '';
            const displaySeconds = seconds > 0 || (hours === 0 && minutes === 0) ? `${seconds}s` : '';
            if (totalSeconds === 0 && ms > 0) return "< 1s";
            
            return (displayHours + displayMinutes + displaySeconds).trim();
        }

        /** Formatta un timestamp in ora leggibile. */
        function formatTime(timestamp) {
            if (!timestamp) return 'N/A';
            return new Date(timestamp).toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        /** Formatta un timestamp in data leggibile. */
        function formatDate(timestamp) {
            if (!timestamp) return 'N/A';
            return new Date(timestamp).toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit', year: 'numeric' });
        }
        
        // --- Logica Timer Dinamico ---
        
        /** Calcola e aggiorna il tempo trascorso per l'attività attiva. */
        function updateActiveTimerDisplay() {
            const display = document.getElementById('active-timer-display');
            const runningActivityName = document.getElementById('running-activity-name');
            const activeTimerCard = document.getElementById('active-timer-card');
            
            if (state.activeActivity) {
                const activity = state.activities.find(a => a.id === state.activeActivity.id);
                const startTime = state.activeActivity.startTime;
                const elapsedMs = Date.now() - startTime;
                
                display.textContent = formatDuration(elapsedMs, true); 
                runningActivityName.textContent = activity ? activity.name.toUpperCase() : 'ATTIVITÀ SCONOSCIUTA';
                activeTimerCard.classList.remove('hidden');

            } else {
                // Se l'attività è stata fermata, interrompi l'intervallo
                stopTimer();
            }
        }

        /** Avvia il timer di aggiornamento ogni secondo. */
        function startTimer() {
            if (timerInterval === null && state.activeActivity !== null) {
                // Esegue subito e poi ogni 1000ms
                updateActiveTimerDisplay();
                timerInterval = setInterval(updateActiveTimerDisplay, 1000);
            }
        }

        /** Interrompe il timer e nasconde il display. */
        function stopTimer() {
            if (timerInterval !== null) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            // Nasconde il display del timer attivo
            document.getElementById('active-timer-card').classList.add('hidden');
        }

        // --- Logica Principale di Tracciamento ---

        /** Gestisce l'evento di click del pulsante (Start/Stop). */
        function toggleTracking(activityId) {
            const now = Date.now();
            const activity = state.activities.find(a => a.id === activityId);
            if (!activity) return;

            // 1. Termina l'attività precedente (se presente)
            if (state.activeActivity) {
                const previousId = state.activeActivity.id;
                const previousActivity = state.activities.find(a => a.id === previousId);

                if (previousId === activityId || previousId !== activityId) {
                    const durationMs = now - state.activeActivity.startTime;

                    // Crea il log
                    const newLog = {
                        activityId: previousId,
                        activityName: previousActivity ? previousActivity.name : 'Attività Sconosciuta',
                        date: formatDate(state.activeActivity.startTime),
                        startTime: state.activeActivity.startTime,
                        endTime: now,
                        durationMs: durationMs,
                        durationFormatted: formatDuration(durationMs)
                    };
                    addLogToDatabase(newLog); // Invia il log al DB/LocalStorage

                    // Aggiorna il totale cumulativo
                    state.runningTotalMs[previousId] = (state.runningTotalMs[previousId] || 0) + durationMs;
                    
                    // Termina il timer dinamico
                    stopTimer();

                    // Se stavamo fermando la stessa attività, resettiamo e usciamo
                    if (previousId === activityId) {
                        state.activeActivity = null;
                        renderUI(); // [FEEDBACK FIX] Aggiorna immediatamente l'interfaccia utente (pulsanti e totali)
                        saveState(); // Salva lo stato di stop/totali
                        return;
                    }
                }
            }

            // 2. Avvia la Nuova Attività (o aggiorna dopo lo stop)
            state.activeActivity = { id: activityId, startTime: now };
            renderUI(); // [FEEDBACK FIX] Aggiorna immediatamente l'interfaccia utente (pulsanti e totali)
            saveState(); // Salva lo stato di start
        }

        // --- Modale per Aggiunta/Eliminazione (Omesse per brevità, non modificate) ---

        let currentModalAction = null;
        let currentActivityId = null;
        let modalInputRef = null;

        function showModal(action, activityId = null) {
            const modal = document.getElementById('customModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalBody = document.getElementById('modalBody');
            const modalConfirm = document.getElementById('modalConfirm');
            const modalInput = document.getElementById('modalInput');
            
            modalInputRef = modalInput;
            
            currentModalAction = action;
            currentActivityId = activityId;
            
            modalInput.value = '';
            modalInput.classList.add('hidden');

            switch (action) {
                case 'add':
                    modalTitle.textContent = 'Aggiungi Nuova Attività';
                    modalBody.textContent = 'Inserisci il nome dell\'attività:';
                    modalInput.classList.remove('hidden');
                    modalConfirm.textContent = 'Aggiungi';
                    modalConfirm.className = modalConfirm.className.replace(/bg-red-\d+/g, 'bg-green-600').replace(/hover:bg-red-\d+/g, 'hover:bg-green-700');
                    break;
                case 'delete':
                    const activity = state.activities.find(a => a.id === activityId);
                    modalTitle.textContent = 'Elimina Attività';
                    modalBody.innerHTML = `Sei sicuro di voler eliminare l'attività **${activity ? activity.name : 'Sconosciuta'}**? I log storici verranno conservati.`;
                    modalConfirm.textContent = 'Conferma Eliminazione';
                    modalConfirm.className = modalConfirm.className.replace(/bg-green-\d+/g, 'bg-red-600').replace(/hover:bg-green-\d+/g, 'hover:bg-red-700');
                    break;
            }
            modal.classList.remove('hidden');
            if (action === 'add') {
                setTimeout(() => modalInputRef.focus(), 100);
            }
        }

        function closeModal() {
            document.getElementById('customModal').classList.add('hidden');
        }

        function handleModalConfirmation() {
            switch (currentModalAction) {
                case 'add':
                    const newName = document.getElementById('modalInput').value.trim();
                    if (newName) addActivity(newName);
                    break;
                case 'delete':
                    if (currentActivityId) deleteActivity(currentActivityId);
                    break;
            }
            closeModal();
        }

        // --- Logica di Gestione delle Attività (Omesse per brevità, non modificate) ---

        /** Aggiunge una nuova attività (chiamata dalla modale). */
        function addActivity(newName, newId = null) {
            const id = newId || generateId();
            
            // Assegna un colore casuale e memorizzalo per consistenza se l'attività è nuova
            let color = randomColorMap[id];
            if (!color) {
                const available = availableColors.filter(c => !Object.values(randomColorMap).includes(c));
                color = available.length > 0 ? available[0] : availableColors[Math.floor(Math.random() * availableColors.length)];
                randomColorMap[id] = color;
            }
            const hover = color.replace('-600', '-700');

            // Verifica se l'attività esiste già (in caso di importazione)
            const existingActivity = state.activities.find(a => a.id === id);
            if (existingActivity) {
                // Se esiste, aggiorna solo il nome se è diverso
                existingActivity.name = newName.trim();
                existingActivity.color = color;
                existingActivity.hover = hover;
            } else {
                state.activities.push({
                    id: id,
                    name: newName.trim(),
                    color: color,
                    hover: hover
                });
                state.runningTotalMs[id] = state.runningTotalMs[id] || 0;
            }

            saveState();
            renderUI();
        }

        /** Rinomina un'attività esistente. */
        function renameActivity(activityId) {
            const activity = state.activities.find(a => a.id === activityId);
            if (!activity) return;

            const newName = document.getElementById(`rename-input-${activityId}`).value.trim();
            if (newName === "" || newName === activity.name) return;

            activity.name = newName;
            
            saveState();
            renderUI(); // Aggiorna UI per riflettere il nuovo nome ovunque
        }

        /** Elimina un'attività (chiamata dalla modale). */
        function deleteActivity(activityId) {
            
            // 1. Termina e logga l'attività attiva se è quella che si sta eliminando
            if (state.activeActivity && state.activeActivity.id === activityId) {
                const now = Date.now();
                const durationMs = now - state.activeActivity.startTime;
                
                // Logga la sessione parziale
                const deletedActivity = state.activities.find(a => a.id === activityId);
                const logName = deletedActivity ? deletedActivity.name : 'Attività Eliminata';

                const newLog = {
                    activityId: activityId, 
                    activityName: `Terminato (pre-eliminazione): ${logName}`,
                    date: formatDate(state.activeActivity.startTime),
                    startTime: state.activeActivity.startTime,
                    endTime: now,
                    durationMs: durationMs,
                    durationFormatted: formatDuration(durationMs)
                };
                
                addLogToDatabase(newLog);

                state.runningTotalMs[activityId] = (state.runningTotalMs[activityId] || 0) + durationMs;
                state.activeActivity = null; // Resetta l'attività attiva
            }
            
            // 2. Rimuovi dall'array delle attività
            state.activities = state.activities.filter(a => a.id !== activityId);

            // 3. Rimuovi dal totale cumulativo
            delete state.runningTotalMs[activityId];
            
            saveState(); 
            renderUI();
        }

        // --- Funzioni di Esportazione/Importazione CSV (Omesse per brevità, non modificate) ---
        function exportLogsToCSV() {
            if (state.logs.length === 0) {
                alert("Nessun log da esportare."); 
                return;
            }

            const header = [
                "ID Attivita'", 
                "Nome Attivita'", 
                "Data", 
                "Ora Inizio (Timestamp)", 
                "Ora Fine (Timestamp)", 
                "Durata (ms)", 
                "Durata Formattata"
            ].join(',');
            
            const rows = state.logs.map(log => {
                const escapeQuotes = (str) => `"${String(str).replace(/"/g, '""')}"`;
                
                return [
                    escapeQuotes(log.activityId || 'unknown'),
                    escapeQuotes(log.activityName || 'Sconosciuta'),
                    escapeQuotes(log.date || 'N/A'),
                    log.startTime,
                    log.endTime,
                    log.durationMs,
                    escapeQuotes(log.durationFormatted || 'N/A')
                ].join(',');
            });

            const csvContent = [header, ...rows].join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            link.href = URL.createObjectURL(blob);
            link.download = `time_tracker_logs_${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function triggerImport() {
            document.getElementById('importFileInput').click();
        }

        function importLogsFromCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const csvData = e.target.result;
                processCSV(csvData);
                event.target.value = null; 
            };
            reader.readAsText(file);
        }

        function processCSV(csvString) {
            const lines = csvString.split('\n').filter(line => line.trim() !== '');
            if (lines.length < 2) {
                alert("Il file CSV è vuoto o non contiene dati validi.");
                return;
            }

            const dataLines = lines.slice(1);
            
            const importedLogs = [];
            const newActivitiesMap = {}; 
            const newTotals = {}; 

            const unescapeQuotes = (field) => {
                if (field.startsWith('"') && field.endsWith('"')) {
                    field = field.slice(1, -1);
                }
                return field.replace(/""/g, '"');
            };

            dataLines.forEach(line => {
                // Parsing CSV semplificato
                const fields = [];
                let inQuote = false;
                let currentField = '';
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        if (inQuote && i + 1 < line.length && line[i + 1] === '"') {
                            currentField += '"';
                            i++; 
                        } else {
                            inQuote = !inQuote;
                        }
                    } else if (char === ',' && !inQuote) {
                        fields.push(currentField);
                        currentField = '';
                    } else {
                        currentField += char;
                    }
                }
                fields.push(currentField); 
                

                if (fields.length >= 7) {
                    const log = {
                        activityId: unescapeQuotes(fields[0]).trim() || generateId(),
                        activityName: unescapeQuotes(fields[1]).trim() || 'Attività Importata',
                        date: unescapeQuotes(fields[2]).trim(),
                        startTime: parseInt(fields[3]) || Date.now(),
                        endTime: parseInt(fields[4]) || Date.now(),
                        durationMs: parseInt(fields[5]) || 0,
                        durationFormatted: unescapeQuotes(fields[6]).trim()
                    };
                    
                    if (log.durationMs >= 0) {
                        importedLogs.push(log);
                        
                        if (!newActivitiesMap[log.activityId]) {
                            newActivitiesMap[log.activityId] = log.activityName;
                        }
                        
                        newTotals[log.activityId] = (newTotals[log.activityId] || 0) + log.durationMs;
                    }
                }
            });

            if (importedLogs.length === 0) {
                alert("Nessun log valido trovato nel file.");
                return;
            }

            Object.entries(newActivitiesMap).forEach(([id, name]) => {
                addActivity(name, id);
            });
            
            Object.entries(newTotals).forEach(([id, total]) => {
                 state.runningTotalMs[id] = total; 
            });
            
            state.logs = importedLogs;
            state.logs.sort((a, b) => b.startTime - a.startTime);


            saveState(); 
            renderUI();
            
            alert(`Importazione completata. ${importedLogs.length} log caricati con successo.`);
        }

        // --- Funzioni di Rendering (Aggiornamento UI) ---

        function renderUI() {
            // Controlla il timer in base allo stato
            if (state.activeActivity) {
                startTimer();
            } else {
                stopTimer();
            }
            
            renderActivityButtons();
            renderTotals();
            renderManagement();
        }

        function renderActivityButtons() {
            const container = document.getElementById('activity-buttons');
            container.innerHTML = '';
            
            if (state.activities.length === 0) {
                 container.innerHTML = '<p class="text-center text-gray-400 py-4 col-span-2">Aggiungi un\'attività per iniziare a tracciare.</p>';
                 return;
            }

            // Imposta il layout dei bottoni in modo che si adattino alla larghezza
            container.className = `grid gap-4 mb-6 ${state.activities.length <= 2 ? 'grid-cols-2' : 'grid-cols-1 md:grid-cols-2'}`;
            
            state.activities.forEach(activity => {
                const isRunning = state.activeActivity && state.activeActivity.id === activity.id;
                const button = document.createElement('button');
                
                button.id = `btn-${activity.id}`;
                button.onclick = () => toggleTracking(activity.id);
                // Rimuove classi che nascondevano il testo, mantiene il padding e la dimensione minima
                button.className = `activity-button w-full px-4 py-3 rounded-xl font-bold text-sm shadow-lg text-white transition duration-200 ease-in-out`;
                
                let classes = '';
                if (isRunning) {
                    // Stato STOP (attivo/rosso)
                    classes = 'bg-red-600 hover:bg-red-700 active';
                    button.textContent = `STOP ${activity.name.toUpperCase()}`;
                } else {
                    // Stato START (non attivo/colore assegnato)
                    classes = `${activity.color} ${activity.hover}`;
                    button.textContent = `START ${activity.name.toUpperCase()}`;
                }
                
                button.className += ' ' + classes;
                
                container.appendChild(button);
            });
        }

        function renderTotals() {
            const container = document.getElementById('totals-display-body');
            container.innerHTML = '';
            
            if (state.activities.length === 0) {
                container.innerHTML = '<p class="text-sm text-gray-500 italic">Nessun totale da visualizzare.</p>';
                return;
            }

            state.activities.forEach(activity => {
                const totalMs = state.runningTotalMs[activity.id] || 0;
                const activityColorClass = activity.color.replace('bg-', 'text-').replace('-600', '-400');

                const totalDiv = document.createElement('div');
                totalDiv.className = `text-base font-medium ${activityColorClass} flex justify-between`;
                totalDiv.innerHTML = `<span>${activity.name}:</span> <span>${formatDuration(totalMs)}</span>`;
                container.appendChild(totalDiv);
            });
        }

        function renderLogs() {
            const logContainer = document.getElementById('log-container');
            logContainer.innerHTML = '';

            if (state.logs.length === 0) {
                logContainer.innerHTML = '<p class="text-center text-gray-400 py-4">Nessuna sessione tracciata finora.</p>';
                return;
            }

            // Ordina i log per tempo di inizio (più recenti in cima), solo i primi 10
            state.logs.slice(0, 10).forEach((log) => {
                const activityConfig = state.activities.find(a => a.id === log.activityId);
                const colorClass = activityConfig ? activityConfig.color.replace('bg-', 'text-') : 'text-gray-400';

                const logItem = document.createElement('div');
                logItem.className = `p-3 rounded-lg border-l-4 border-gray-600 mb-2 bg-gray-700/50 flex justify-between items-start`;
                logItem.innerHTML = `
                    <div class="flex-grow">
                        <span class="font-semibold ${colorClass}">${log.activityName}</span>
                        <div class="text-sm text-gray-400 mt-1">
                            ${log.date} | ${formatTime(log.startTime)} - ${formatTime(log.endTime)}
                        </div>
                    </div>
                    <div class="text-lg font-bold flex-shrink-0 ml-4">
                        ${log.durationFormatted}
                    </div>
                `;
                logContainer.appendChild(logItem);
            });
            
            if (state.logs.length > 10) {
                const count = state.logs.length - 10;
                 const moreInfo = document.createElement('p');
                 moreInfo.className = 'text-center text-sm text-gray-500 mt-2';
                 moreInfo.textContent = `... e altre ${count} sessioni non visualizzate.`;
                 logContainer.appendChild(moreInfo);
            }
        }
        
        function renderManagement() {
            const container = document.getElementById('management-list');
            container.innerHTML = '';

            state.activities.forEach(activity => {
                const item = document.createElement('div');
                item.className = 'flex space-x-2 mb-3 items-center';
                
                item.innerHTML = `
                    <input type="text" id="rename-input-${activity.id}" 
                           value="${activity.name}" 
                           onchange="renameActivity('${activity.id}')"
                           class="management-input flex-grow p-2 rounded-lg text-sm"
                           placeholder="Nuovo nome attività">
                    
                    <button onclick="renameActivity('${activity.id}')" 
                            class="px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium transition duration-150">
                        Rinomina
                    </button>
                    
                    <button onclick="showModal('delete', '${activity.id}')" 
                            class="px-3 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg text-sm font-medium transition duration-150">
                        Elimina
                    </button>
                `;
                container.appendChild(item);
            });
        }

        function toggleManagementVisibility() {
            const container = document.getElementById('management-container');
            const button = document.getElementById('management-toggle-btn');
            const isHidden = container.classList.toggle('hidden');
            button.textContent = isHidden ? 'Mostra Gestione Attività e Dati' : 'Nascondi Gestione Attività e Dati';
        }

        // Espone le funzioni a livello globale per l'HTML
        window.renameActivity = renameActivity;
        window.showModal = showModal;

        window.onload = function() {
            initFirebase();
            
            document.getElementById('add-activity-btn').onclick = () => showModal('add');
            document.getElementById('management-toggle-btn').onclick = toggleManagementVisibility;
            document.getElementById('export-csv-btn').onclick = exportLogsToCSV;
            document.getElementById('import-csv-btn').onclick = triggerImport;
            document.getElementById('importFileInput').onchange = importLogsFromCSV;
            
            document.getElementById('modalConfirm').onclick = handleModalConfirmation;
            document.getElementById('modalCancel').onclick = closeModal;
            document.getElementById('modalCloseBtn').onclick = closeModal;
        };
    </script>
</head>
<body class="p-4">

    <!-- Modale Custom per Aggiunta/Eliminazione -->
    <div id="customModal" class="hidden fixed inset-0 flex items-center justify-center modal-overlay">
        <div class="modal-content p-6 rounded-2xl shadow-2xl max-w-sm w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h3 id="modalTitle" class="text-xl font-bold text-white"></h3>
                <button id="modalCloseBtn" class="text-gray-400 hover:text-white transition">&times;</button>
            </div>
            
            <p id="modalBody" class="text-gray-300 mb-4"></p>
            
            <!-- Input per Aggiunta -->
            <input type="text" id="modalInput" 
                   class="management-input w-full p-2 rounded-lg text-sm mb-4 hidden"
                   placeholder="Nome della nuova attività">

            <div class="flex justify-end space-x-3">
                <button id="modalCancel" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg text-white font-medium transition duration-150">
                    Annulla
                </button>
                <button id="modalConfirm" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg text-white font-medium transition duration-150">
                    Conferma
                </button>
            </div>
        </div>
    </div>

    <!-- Contenitore Principale (simula l'aspetto di un widget) -->
    <div class="widget-card max-w-lg mx-auto p-6 rounded-2xl shadow-xl">
        <div class="flex justify-between items-center mb-6 border-b border-gray-700 pb-3">
            <h1 class="text-2xl font-extrabold text-white">
                Tracciatore di Attività
            </h1>
            <span id="status" class="text-sm font-medium text-green-400">Caricamento...</span>
        </div>
        
        <div id="local-warning" class="hidden p-3 mb-4 bg-yellow-900/50 border border-yellow-500 rounded-lg text-sm text-yellow-300 font-medium">
            ⚠️ **Modalità Locale (Desktop):** I dati sono salvati nel browser (`localStorage`). Non sono sincronizzati con il cloud.
        </div>

        <div class="text-xs text-gray-500 mb-4" id="user-id-display">Utente ID: Caricamento...</div>

        <!-- Timer Attivo Dinamico -->
        <div id="active-timer-card" class="hidden mb-6 p-4 rounded-xl bg-red-800/70 border-2 border-red-600 shadow-2xl transition duration-300">
            <div class="flex items-center justify-between">
                <div class="text-sm text-red-200 font-medium tracking-wider">ATTIVITÀ IN CORSO</div>
                <div class="text-xs text-red-200" id="running-activity-name"></div>
            </div>
            <div class="text-5xl font-extrabold text-white mt-1 text-center font-mono" id="active-timer-display">
                00:00
            </div>
        </div>

        <!-- Sezione Pulsanti Attività -->
        <div id="activity-buttons" class="grid grid-cols-2 gap-4 mb-6">
            <!-- I pulsanti verranno renderizzati qui da JavaScript -->
        </div>

        <!-- Totali Cumulativi -->
        <div id="totals-display" class="mb-6 space-y-2 p-3 bg-gray-800 rounded-lg">
            <h2 class="text-lg font-semibold text-gray-300">Totali Cumulativi</h2>
            <div id="totals-display-body" class="space-y-1">
                <!-- I totali verranno renderizzati qui da JavaScript -->
            </div>
        </div>
        
        <!-- Gestione Attività e Dati (Area a scomparsa) -->
        <div class="mb-6 border-t border-gray-700 pt-4">
            <button id="management-toggle-btn" class="w-full text-center py-2 bg-gray-600 hover:bg-gray-700 rounded-lg text-sm font-medium text-white transition duration-150 mb-4">
                Mostra Gestione Attività e Dati
            </button>
            
            <div id="management-container" class="hidden">
                <h3 class="text-xl font-semibold text-gray-300 mb-3">Gestione Attività</h3>
                
                <button id="add-activity-btn" class="w-full px-4 py-3 bg-green-600 hover:bg-green-700 rounded-xl font-bold text-sm shadow-lg text-white mb-4 transition duration-150">
                    + Aggiungi Nuova Attività
                </button>
                
                <div id="management-list" class="space-y-3 mb-6">
                    <!-- I campi di ridenominazione e i pulsanti verranno renderizzati qui -->
                </div>

                <h3 class="text-xl font-semibold text-gray-300 mb-3 border-t border-gray-700 pt-3">Backup e Ripristino Dati</h3>

                 <!-- Campo di input nascosto per il file -->
                <input type="file" id="importFileInput" accept=".csv">

                <button id="import-csv-btn" class="w-full px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-sm font-medium text-white transition duration-150">
                    Carica Log da CSV (Ripristino)
                </button>

            </div>
        </div>

        <!-- Log delle Sessioni -->
        <div id="log-section" class="border-t border-gray-700 pt-4">
            <h2 class="text-lg font-semibold text-gray-300 mb-3 border-b border-gray-700 pb-2">
                Log Recenti (Max 10)
            </h2>
            <div id="log-container" class="space-y-2 max-h-60 overflow-y-auto mb-4">
                <!-- I log verranno renderizzati qui da JavaScript -->
            </div>
            
            <!-- Pulsante Esporta -->
            <button id="export-csv-btn" class="w-full px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-sm font-medium text-white transition duration-150">
                Scarica Log Completo (CSV/Excel)
            </button>
        </div>
    </div>

</body>
</html>
